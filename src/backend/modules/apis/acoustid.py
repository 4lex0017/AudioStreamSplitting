"""
This module provides functionality to access the AcoustID API (https://acoustid.org)
to identify a segment of song data. AcoustID will only recognise a segment if it is a full
song.

Requests and fingerprinting are performed using the ``acoustid`` library, so exceptions raised by
this module will use the exception classes from ``acoustid``.
"""

import os

import acoustid
from modules.audio_stream_io import save_numpy_as_audio_file

METADATA_ALL = ["tracks", "recordings", "releasegroups"]


def create_fingerprint(song_data, samplerate):
    """Create a chromaprint/AcoustID fingerprint for the given audio data
    in order to identify it using AcoustID.
    As of current, this works by writing the data to a temporary file
    and using the fpcalc command line tool to generate the fingerprint.
    The temporary file is deleted immediately afterwards.

    TODO: If it becomes feasible to build and distribute DLL versions of chromaprint
    for all target platforms, this should be refactored to use that instead.

    :param song_data: the audio data to generate a fingerprint from.
    :param samplerate: the audio data's sample rate.
    :returns: (song_duration, fingerprint).
        ``song_duration`` is measured in seconds and used for the API call to AcoustID.
        ``fingerprint`` is generated by fpcalc.
    :raise acoustid.NoBackendError: if fpcalc is not installed.
    :raise acoustid.FingerprintGenerationError: if fingerprint generation fails.
    """
    filename = "TEMP_FILE_FOR_FINGERPRINTING"
    save_numpy_as_audio_file(song_data, os.path.abspath(filename), "", rate=samplerate)

    filename_with_path = os.path.abspath(filename + ".mp3")
    fingerprint_duration, fingerprint = acoustid.fingerprint_file(
        filename_with_path, force_fpcalc=True
    )
    os.remove(filename_with_path)
    return (fingerprint_duration, fingerprint)


def lookup(fingerprint, fingerprint_duration, api_key):
    """Get data about the provided fingerprint from the AcoustID API.
    This uses the ``pyacoustid`` library to make the actual API call, but parsing
    it is handled through custom functions to allow retrieving more metadata.

    The following metadata can be retrieved:
        * artist
        * title
        * album
        * albumartist

    :param fingerprint: the fingerprint generated using ``_create_fingerprint``.
    :param fingerprint_duration: duration of the fingerprinted data, in seconds.
    :returns: A ``list`` of ``dict``s containing the results.
        Example::

            [
              {
                "title": "Thunderstruck",
                "artist": "AC/DC",
                "album": "The Razor's Edge",
                "albumartist": "AC/DC"
              },
              {
                "title": "Thunderstruck",
                "artist": "2Cellos"
              }
            ]
    :raise acoustid.WebServiceError: if the request fails.
    """
    return _parse_lookup_result(
        acoustid.lookup(
            api_key,
            fingerprint,
            fingerprint_duration,
            meta=METADATA_ALL,
        )
    )


def _parse_lookup_result(data):
    """This is an extended/altered version of acoustid.parse_lookup_result.
    Retrieve the song metadata from the data returned by an AcoustID API call.
    Results that do not contain recordings are discarded, as they aren't useful.

    The following metadata can be retrieved:
        * title
        * artist
        * album
        * albumartist

    :param data: The parsed JSON response from acoustid.lookup().
    :returns: A ``list`` of ``dict``s containing metadata.
    :raise acoustid.WebServiceError: if the response is incomplete or the request failed.
    """
    print(data)
    if data["status"] != "ok":
        raise acoustid.WebServiceError("status: %s" % data["status"])
    if "results" not in data:
        raise acoustid.WebServiceError("results not included")

    results = []

    for result in data["results"]:
        if "recordings" in result:
            results = _append_results_for_recordings(result["recordings"], results)

    return results


def _append_results_for_recordings(recordings, results: list):
    """Go through all the given recordings, parse their metadata into a dict and append them to the
    results list. To return all possible results, go through each release group the recording is in
    and append a separate result, so releases on different albums are identified separately.

    Metadata that do not contain an artist or a title are discarded, as they are not useful.

    The following metadata can be retrieved:
        * artist
        * title
        * album
        * albumartist

    :param recordings: The recordings to parse
    :param results: The list to append the results to.
    :returns: The list with the appended results.
    """
    for recording in recordings:
        # Get the artist if available.
        if "artists" not in recording or "title" not in recording:
            continue
        artist_name = _join_artist_names(recording["artists"])
        for releasegroup in recording["releasegroups"]:
            results.append(
                _get_result_for_releasegroup(
                    releasegroup, artist_name, recording["title"]
                )
            )
    return results


def _get_result_for_releasegroup(releasegroup, artist_name: str, title: str):
    """Convert the given release group with the given parameters into a ``dict`` containing
    the metadata.

    The ``dict`` will have the following keys:
      * artist
      * title
      * album
      * albumartist

    If no album artist is set, the albumartist field will be ``None`` instead.

    :param releasegroup: The release group.
    :param artist_name: The artist name.
    :param title: The title.
    :returns: The ``dict`` containing the parsed release group.
    """
    album_artist_name = (
        _join_artist_names(releasegroup["artists"])
        if "artists" in releasegroup
        else None
    )
    return {
        "artist": artist_name,
        "title": title,
        "album": releasegroup["title"],
        "albumartist": album_artist_name,
    }


def _join_artist_names(artists):
    """Join all artist names from the given artists list.

    :param artists: List containing all artists to join together.
    :returns: The artist names, joined together with "; " as a separator.
    """
    names = [artist["name"] for artist in artists]
    return "; ".join(names)
